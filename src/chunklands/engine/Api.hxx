#ifndef __CHUNKLANDS_ENGINE_API_HXX__
#define __CHUNKLANDS_ENGINE_API_HXX__

#define BOOST_THREAD_VERSION 4
#define BOOST_THREAD_PROVIDES_FUTURE
#define BOOST_THREAD_PROVIDES_EXECUTORS
#define BOOST_THREAD_PROVIDES_FUTURE_CONTINUATION
#include <boost/thread/executors/loop_executor.hpp>
#include <boost/thread/executors/serial_executor.hpp>
#include <boost/thread/thread.hpp>
#include <boost/signals2.hpp>
#include <set>

namespace chunklands::engine {

  struct WindowHandle;

  class Api {
  public:
    Api() : serial_(loop_) {}
    ~Api() {
      Stop();
    }

  public:
    void RunCommands();
    void Stop() {
      if (!serial_.closed()) {
        serial_.close();
      }
    }

  public:
    // GLFW
    boost::future<void>
    GLFWInit();

    void
    GLFWStartPollEvents(bool poll);

    bool
    GLFWStartPollEvents() const { return GLFW_start_poll_events; }
    
    
    // Window
    boost::future<WindowHandle*>
    WindowCreate(int width, int height, std::string title);

    boost::future<void>
    WindowLoadGL(WindowHandle* handle);

    boost::signals2::scoped_connection
    WindowOn(WindowHandle* handle, const std::string& event, std::function<void()> callback);
    
  private:
    template<class F, class R = std::result_of_t<F&&()>>
    inline boost::future<R> EnqueueTask(F&& fn) {
      boost::packaged_task<R()> task(std::forward<F>(fn));
      boost::future<R> result = task.get_future();
      serial_.submit(std::move(task));

      return result;
    }

  private:
    boost::loop_executor loop_;
    boost::serial_executor serial_;

    std::set<WindowHandle*> window_instances_;

    bool GLFW_start_poll_events = false;
  };

} // namespace chunklands::engine

#endif